* Project Objectives and Approach

** Objectives
The objectives of this project are the following:
- Evaluate the practicality of dependently-typed programming languages
- Evaluate Idris in particular in this regard
- Understand what kinds of correctness properties can be expressed
- Understand the scale at which formal verification with dependent types can be
  applied in a software project
- Explore and evaluate multiple approaches to building software with dependent
  types
- Discover the main pain points of approaching this style of development as
  someone with functional programming experience in some ML family language

*** Practicality of Dependently-Typed Programming Languages
Much of the literature about dependent types has been focused on advancing
research in the study of the theory of the field. This has manifested itself by
way of new or novel approaches to building dependently-typed systems. Despite
the push to advance the underlying theory and concepts not much research has
emerged in the area of evaluating these languages' applicability to software
engineering as practised by programmers in general.

Some research exists such as Wouter Swierstra's 2012 evaluation
cite:swierstra_xmonad_2012 of program extraction from Coq to Haskell of a
drop-in replacement for one of the modules of the xmonad window manager. This
projects aim to further supplement this area of study with more data taking into
account the state-of-the-art at the time of writing.

*** Expression of Correctness Properties
Many of the current teaching examples involving dependent types present fairly
simple examples of correctness properties. In order to provide a cohesive
example that illustrates one or two points this is understandable.

This project aims to outline some more in-depth example of expressing
complicated correctness properties. By doing this we to understand what some of
the limitations are in terms of the expressivity of specification of a dependent
type as well as the feasibility of implementing a program to that specification.

*** Scale of Applicability of Dependent Types
In real-world settings in a software engineering project we are often faced with
certain time, performance and other delivery constraints. Projects do not have
unlimited time to work with crafting and deploying a perfectly verified piece of
software. While dependent types can give us more guarantees about the
correctness of our programs that doesn't mean that we will be able to deliver a
fully verified system within real-world constraints such as deadlines.

This project aims to understand where dependent types are most suited to being
applied both in terms of problem domains as well as scale. The aim is to see if
the biggest return on investment will be in verifying critical algorithms and
processes within a system, verifying a system at the boundaries between
subsystems or by applying formal verification using dependent types across an
entire system.

*** Development Approaches when using Dependent Types
A number of development approaches exist when using dependent types. One could
take a bottom-up approach in that existing code that has no existing correctness
properties is given some and then the proof obligations are discharged from the
implementation out to the type signature. Another approach that is seeing more
traction is the top-down type-driven or proof-driven development style. This
approach starts by deciding on a specification in a type and driving the
implementation based on that specification. This approach is outlined fully in
its own section of the report.

Among the project's aims is to see how these approaches can be applied to the
case studies and to determine where one might favour one approach over the other
for a particular problem.

*** Pain Points when using Dependent Types
Current dependently-typed languages such as Agda and Idris bear much surface
syntax similarity to ML family languages such as Haskell. However, past these
surface details the underlying type frameworks differ quite a bit. Even with
experience and a good knowledge of a language like Haskell there will be many
pain points when learning how to use dependent types. This project aims to
detail some of these hurdles that will be common when beginning to use these
type systems.

** Approach
The approach by which the evaluation of the above objectives took place is by
implementing a number of case studies. In order for these case studies to have
significant meaning they were focused on implementing real world algorithms that
have interesting correctness properties that can be expressed about them.

In the implementation of these case studies multiple software engineering tools
and approaches were used. This included trying to implement the case studies
using different levels of correctness guarantees. It also meant that the case
studies should be implemented with different engineering approaches such as the
top-down type-driven approach and the bottom-up approach where correctness
properties are validated after the program has been implemented. The case
studies also made use of different tooling such as working with standard tools
like text editors as well as more semantically rich interactive editing
environments.

** Interactive Editing Modes for Idris
A feature of Idris used heavily throughout the implementation of the project was
the interactive editing environment available to text editors such as Emacs, Vim
and Atom. This interactive environment works in a similar way to tools such as
Coq's Proof General cite:proof_general mode and Agda's interactive mode for
Emacs.

The main difference in Idris' editor support is that it is compatible with
multiple text editors by providing a client-server model where the editor plugin
is a client to an instance of the Idris compiler that acts as a server. This
compiler server responds to commands with information about where to insert some
string of characters or documentation such as the type of a function or a
documentation string. It is also responsible for reporting back information
about type errors, environments of definitions and typed holes.

*** Insert Definition
One of the most useful commands is the definition command. If we have some
initial definition of a type signature we can issue a keyboard shortcut to have
the interactive environment create an initial definition of the function with
variables inserted and an initial typed hole as the right-hand-side of the
definition.

The default names for our arguments will be non-descriptive in that they will
have single-letter names such as =x=, =y=, =z=. We can guide the compiler with the
=%name= directive to generate more specific or domain relevant names for a given
type. The list type in the standard library uses this facility to generate more
appropriate names using =%name List xs, ys, zs, ws=. These new names are used when
we generate initial definitions with arguments of type =List=.

*** Case Split
Another command that is regularly used is the case split command. The command
will create separate clauses in a function definition to cover each different
case of a data type definition. This is quite useful after creating an initial
definition and we want to do case analysis on one of our arguments.

This command also helps achieve a definition which will pass the Idris totality
checker. If we have gotten the compiler to generate the cases for us we can be
sure that we haven't caused an error by failing to remember to insert a case for
one of our data constructors. In the following example we create a data type
representing colours and ask the compiler to provide definitions for each of the
different cases.

#+CAPTION: Generated function clauses by case splitting
#+BEGIN_SRC idris
data Colour : Type where
  Red : Colour
  Green : Colour
  Blue : Colour

colourToString : Colour -> String
colourToString Red = ?colourToString_rhs_1
colourToString Green = ?colourToString_rhs_2
colourToString Blue = ?colourToString_rhs_3
#+END_SRC

If we were to instead try and manually create these definitions we may forget to
insert the case for the =Green= constructor. If we don't check this definition for
totality and try to call it with the value =Green= then it will result in a
runtime error causing our program to crash despite our =colourToString= function
type-checking. Automatic case splits driven by the compiler's semantic
information help us achieve the total functional programming style that Idris
advocates.

#+CAPTION: Buggy code with incomplete manual case splitting
#+BEGIN_SRC idris
colourToString : Colour -> String
colourToString Blue = "blue"
colourToString Red = "red"
#+END_SRC

*** Proof Search
Often, the value that needs to go in place of a typed hole can be automatically
derived from the values in our environment. By successive case splitting and
refinement of the goal of our typed holes and from our type signature we often
arrive at a point where there is only one sensible definition that fits the type
of the hole. The interactive editing mode offers a proof search command that
will find the value that fits in the typed hole at the current cursor position
and replace the hole with the correct well-typed value.

Automating the definition of our function based on the information the compiler
knows to be true allows for a rapid development cycle in the small scale
problems in our program. With a stringent enough dependent type for our function
we can be fairly sure that the definition found is the ``correct'' one in terms
of the intended semantics of the function. This definition can also be manually
verified for having the intended semantics by inspection or by testing. It is
often worth attempting a proof search on a typed hole initially to see what the
compiler is able to infer for us automatically. In certain situations we do not
have to write any code ourselves.

#+CAPTION: An in-progress editing session using the interactive Idris mode
#+ATTR_LATEX: :width 0.85\linewidth
[[./fig/interactive_idris.png]]

** Type-Driven-Development
# TODO: Fill out section referencing interactive editing
# TODO: Include image from presentation/poster
